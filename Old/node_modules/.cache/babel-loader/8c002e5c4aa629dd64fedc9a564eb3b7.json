{"ast":null,"code":"/*!\n * wavesurfer.js timeline plugin 5.2.0 (2021-08-16)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(\"WaveSurfer\", [], t) : \"object\" == typeof exports ? exports.WaveSurfer = t() : (e.WaveSurfer = e.WaveSurfer || {}, e.WaveSurfer.timeline = t());\n}(self, function () {\n  return (() => {\n    \"use strict\";\n\n    var e = {\n      171: (e, t) => {\n        function a(e, t) {\n          for (var a = 0; a < t.length; a++) {\n            var r = t[a];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n          }\n        }\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = void 0;\n\n        var r = function () {\n          function e(t, a) {\n            var r = this;\n            if (function (e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, e), i.call(this), this.container = \"string\" == typeof t.container ? document.querySelector(t.container) : t.container, !this.container) throw new Error(\"No container for wavesurfer timeline\");\n            this.wavesurfer = a, this.util = a.util, this.params = Object.assign({}, {\n              height: 20,\n              notchPercentHeight: 90,\n              labelPadding: 5,\n              unlabeledNotchColor: \"#c0c0c0\",\n              primaryColor: \"#000\",\n              secondaryColor: \"#c0c0c0\",\n              primaryFontColor: \"#000\",\n              secondaryFontColor: \"#000\",\n              fontFamily: \"Arial\",\n              fontSize: 10,\n              duration: null,\n              zoomDebounce: !1,\n              formatTimeCallback: this.defaultFormatTimeCallback,\n              timeInterval: this.defaultTimeInterval,\n              primaryLabelInterval: this.defaultPrimaryLabelInterval,\n              secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n              offset: 0\n            }, t), this.canvases = [], this.wrapper = null, this.drawer = null, this.pixelRatio = null, this.maxCanvasWidth = null, this.maxCanvasElementWidth = null, this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {\n              return r.render();\n            }, this.params.zoomDebounce) : function () {\n              return r.render();\n            };\n          }\n\n          var t, r, n;\n          return t = e, n = [{\n            key: \"create\",\n            value: function (t) {\n              return {\n                name: \"timeline\",\n                deferInit: !(!t || !t.deferInit) && t.deferInit,\n                params: t,\n                instance: e\n              };\n            }\n          }], (r = [{\n            key: \"init\",\n            value: function () {\n              this.wavesurfer.isReady ? this._onReady() : this.wavesurfer.once(\"ready\", this._onReady);\n            }\n          }, {\n            key: \"destroy\",\n            value: function () {\n              this.unAll(), this.wavesurfer.un(\"redraw\", this._onRedraw), this.wavesurfer.un(\"zoom\", this._onZoom), this.wavesurfer.un(\"ready\", this._onReady), this.wavesurfer.drawer.wrapper.removeEventListener(\"scroll\", this._onScroll), this.wrapper && this.wrapper.parentNode && (this.wrapper.removeEventListener(\"click\", this._onWrapperClick), this.wrapper.parentNode.removeChild(this.wrapper), this.wrapper = null);\n            }\n          }, {\n            key: \"createWrapper\",\n            value: function () {\n              var e = this.wavesurfer.params;\n              this.container.innerHTML = \"\", this.wrapper = this.container.appendChild(document.createElement(\"timeline\")), this.util.style(this.wrapper, {\n                display: \"block\",\n                position: \"relative\",\n                userSelect: \"none\",\n                webkitUserSelect: \"none\",\n                height: \"\".concat(this.params.height, \"px\")\n              }), (e.fillParent || e.scrollParent) && this.util.style(this.wrapper, {\n                width: \"100%\",\n                overflowX: \"hidden\",\n                overflowY: \"hidden\"\n              }), this.wrapper.addEventListener(\"click\", this._onWrapperClick);\n            }\n          }, {\n            key: \"render\",\n            value: function () {\n              this.wrapper || this.createWrapper(), this.updateCanvases(), this.updateCanvasesPositioning(), this.renderCanvases();\n            }\n          }, {\n            key: \"addCanvas\",\n            value: function () {\n              var e = this.wrapper.appendChild(document.createElement(\"canvas\"));\n              this.canvases.push(e), this.util.style(e, {\n                position: \"absolute\",\n                zIndex: 4\n              });\n            }\n          }, {\n            key: \"removeCanvas\",\n            value: function () {\n              var e = this.canvases.pop();\n              e.parentElement.removeChild(e);\n            }\n          }, {\n            key: \"updateCanvases\",\n            value: function () {\n              for (var e = Math.round(this.drawer.wrapper.scrollWidth), t = Math.ceil(e / this.maxCanvasElementWidth); this.canvases.length < t;) this.addCanvas();\n\n              for (; this.canvases.length > t;) this.removeCanvas();\n            }\n          }, {\n            key: \"updateCanvasesPositioning\",\n            value: function () {\n              var e = this,\n                  t = this.canvases.length;\n              this.canvases.forEach(function (a, r) {\n                var i = r === t - 1 ? e.drawer.wrapper.scrollWidth - e.maxCanvasElementWidth * (t - 1) : e.maxCanvasElementWidth;\n                a.width = i * e.pixelRatio, a.height = (e.params.height + 1) * e.pixelRatio, e.util.style(a, {\n                  width: \"\".concat(i, \"px\"),\n                  height: \"\".concat(e.params.height, \"px\"),\n                  left: \"\".concat(r * e.maxCanvasElementWidth, \"px\")\n                });\n              });\n            }\n          }, {\n            key: \"renderCanvases\",\n            value: function () {\n              var e = this,\n                  t = this.params.duration || this.wavesurfer.backend.getDuration();\n\n              if (!(t <= 0)) {\n                var a,\n                    r = this.wavesurfer.params,\n                    i = this.params.fontSize * r.pixelRatio,\n                    n = parseInt(t, 10) + 1,\n                    s = r.fillParent && !r.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * r.pixelRatio,\n                    o = this.params.height * this.pixelRatio,\n                    l = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio,\n                    h = s / t,\n                    c = this.params.formatTimeCallback,\n                    u = function (e) {\n                  return \"function\" == typeof e ? e(h) : e;\n                },\n                    p = u(this.params.timeInterval),\n                    f = u(this.params.primaryLabelInterval),\n                    d = u(this.params.secondaryLabelInterval),\n                    v = h * this.params.offset,\n                    m = 0,\n                    y = [];\n\n                for (a = 0; a < n / p; a++) y.push([a, m, v]), m += p, v += h * p;\n\n                var w = function (e) {\n                  y.forEach(function (t) {\n                    e(t[0], t[1], t[2]);\n                  });\n                };\n\n                this.setFillStyles(this.params.primaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.primaryFontColor), w(function (t, a, r) {\n                  t % f == 0 && (e.fillRect(r, 0, 1, o), e.fillText(c(a, h), r + e.params.labelPadding * e.pixelRatio, o));\n                }), this.setFillStyles(this.params.secondaryColor), this.setFonts(\"\".concat(i, \"px \").concat(this.params.fontFamily)), this.setFillStyles(this.params.secondaryFontColor), w(function (t, a, r) {\n                  t % d == 0 && (e.fillRect(r, 0, 1, o), e.fillText(c(a, h), r + e.params.labelPadding * e.pixelRatio, o));\n                }), this.setFillStyles(this.params.unlabeledNotchColor), w(function (t, a, r) {\n                  t % d != 0 && t % f != 0 && e.fillRect(r, 0, 1, l);\n                });\n              }\n            }\n          }, {\n            key: \"setFillStyles\",\n            value: function (e) {\n              this.canvases.forEach(function (t) {\n                var a = t.getContext(\"2d\");\n                a && (a.fillStyle = e);\n              });\n            }\n          }, {\n            key: \"setFonts\",\n            value: function (e) {\n              this.canvases.forEach(function (t) {\n                var a = t.getContext(\"2d\");\n                a && (a.font = e);\n              });\n            }\n          }, {\n            key: \"fillRect\",\n            value: function (e, t, a, r) {\n              var i = this;\n              this.canvases.forEach(function (n, s) {\n                var o = s * i.maxCanvasWidth,\n                    l = {\n                  x1: Math.max(e, s * i.maxCanvasWidth),\n                  y1: t,\n                  x2: Math.min(e + a, s * i.maxCanvasWidth + n.width),\n                  y2: t + r\n                };\n\n                if (l.x1 < l.x2) {\n                  var h = n.getContext(\"2d\");\n                  h && h.fillRect(l.x1 - o, l.y1, l.x2 - l.x1, l.y2 - l.y1);\n                }\n              });\n            }\n          }, {\n            key: \"fillText\",\n            value: function (e, t, a) {\n              var r,\n                  i = 0;\n              this.canvases.forEach(function (n) {\n                var s = n.getContext(\"2d\");\n\n                if (s) {\n                  var o = s.canvas.width;\n                  if (i > t + r) return;\n                  i + o > t && s && (r = s.measureText(e).width, s.fillText(e, t - i, a)), i += o;\n                }\n              });\n            }\n          }, {\n            key: \"defaultFormatTimeCallback\",\n            value: function (e, t) {\n              if (e / 60 > 1) {\n                var a = parseInt(e / 60, 10);\n                return e = (e = parseInt(e % 60, 10)) < 10 ? \"0\" + e : e, \"\".concat(a, \":\").concat(e);\n              }\n\n              return Math.round(1e3 * e) / 1e3;\n            }\n          }, {\n            key: \"defaultTimeInterval\",\n            value: function (e) {\n              return e >= 25 ? 1 : 5 * e >= 25 ? 5 : 15 * e >= 25 ? 15 : 60 * Math.ceil(.5 / e);\n            }\n          }, {\n            key: \"defaultPrimaryLabelInterval\",\n            value: function (e) {\n              return e >= 25 ? 10 : 5 * e >= 25 ? 6 : 4;\n            }\n          }, {\n            key: \"defaultSecondaryLabelInterval\",\n            value: function (e) {\n              return e >= 25 ? 5 : 2;\n            }\n          }]) && a(t.prototype, r), n && a(t, n), e;\n        }();\n\n        t.default = r;\n\n        var i = function () {\n          var e = this;\n          this._onScroll = function () {\n            e.wrapper && e.drawer.wrapper && (e.wrapper.scrollLeft = e.drawer.wrapper.scrollLeft);\n          }, this._onRedraw = function () {\n            return e.render();\n          }, this._onReady = function () {\n            var t = e.wavesurfer;\n            e.drawer = t.drawer, e.pixelRatio = t.drawer.params.pixelRatio, e.maxCanvasWidth = t.drawer.maxCanvasWidth || t.drawer.width, e.maxCanvasElementWidth = t.drawer.maxCanvasElementWidth || Math.round(e.maxCanvasWidth / e.pixelRatio), t.drawer.wrapper.addEventListener(\"scroll\", e._onScroll), t.on(\"redraw\", e._onRedraw), t.on(\"zoom\", e._onZoom), e.render();\n          }, this._onWrapperClick = function (t) {\n            t.preventDefault();\n            var a = \"offsetX\" in t ? t.offsetX : t.layerX;\n            e.fireEvent(\"click\", a / e.wrapper.scrollWidth || 0);\n          };\n        };\n\n        e.exports = t.default;\n      }\n    },\n        t = {};\n    return function a(r) {\n      var i = t[r];\n      if (void 0 !== i) return i.exports;\n      var n = t[r] = {\n        exports: {}\n      };\n      return e[r](n, n.exports, a), n.exports;\n    }(171);\n  })();\n});","map":{"version":3,"sources":["webpack://WaveSurfer.[name]/webpack/universalModuleDefinition","webpack://WaveSurfer.[name]/src/plugin/timeline/index.js","webpack://WaveSurfer.[name]/webpack/bootstrap","webpack://WaveSurfer.[name]/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","TimelinePlugin","params","name","deferInit","instance","_onScroll","wrapper","drawer","scrollLeft","_onRedraw","render","_onReady","ws","wavesurfer","pixelRatio","maxCanvasWidth","width","maxCanvasElementWidth","Math","round","addEventListener","on","_onZoom","_onWrapperClick","e","preventDefault","relX","offsetX","layerX","fireEvent","scrollWidth","this","container","document","querySelector","Error","util","Object","assign","height","notchPercentHeight","labelPadding","unlabeledNotchColor","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","duration","zoomDebounce","formatTimeCallback","defaultFormatTimeCallback","timeInterval","defaultTimeInterval","primaryLabelInterval","defaultPrimaryLabelInterval","secondaryLabelInterval","defaultSecondaryLabelInterval","offset","canvases","debounce","isReady","once","unAll","un","removeEventListener","parentNode","removeChild","wsParams","innerHTML","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","overflowY","createWrapper","updateCanvases","updateCanvasesPositioning","renderCanvases","canvas","push","zIndex","pop","parentElement","totalWidth","requiredCanvases","ceil","length","addCanvas","removeCanvas","canvasesLength","forEach","i","canvasWidth","left","backend","getDuration","totalSeconds","parseInt","getWidth","height1","height2","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","positioning","renderPositions","cb","pos","setFillStyles","setFonts","fillRect","fillText","fillStyle","context","getContext","font","x","y","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","measureText","seconds","pxPerSec","minutes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"mappings":";;;;;CAAA,UAA2CA,CAA3C,EAAiDC,CAAjD,EAAiDA;EAC1B,YAAA,OAAZC,OAAY,IAA8B,YAAA,OAAXC,MAAnB,GACrBA,MAAAA,CAAOD,OAAPC,GAAiBF,CAAAA,EADI,GAEI,cAAA,OAAXG,MAAW,IAAcA,MAAAA,CAAOC,GAArB,GACzBD,MAAAA,CAAO,YAAPA,EAAqB,EAArBA,EAAyBH,CAAzBG,CADyB,GAEC,YAAA,OAAZF,OAAY,GAC1BA,OAAAA,CAAoB,UAApBA,GAAwBD,CAAAA,EADE,IAG1BD,CAAAA,CAAiB,UAAjBA,GAAqBA,CAAAA,CAAiB,UAAjBA,IAAsB,EAA3CA,EAA+CA,CAAAA,CAAiB,UAAjBA,CAA6B,QAA7BA,GAAiCC,CAAAA,EAHtD,CAJL;AADvB,CAAA,CASGK,IATH,EASS,YAAA;EACT,OAAA,CAAA,MAAA;;;;;;;;;;;;;;;;YCiDqBC,CAAAA,GAAAA,YAAAA;UAiEjB,SAAA,CAAA,CAAYC,CAAZ,EAAoBW,CAApB,EAAoBA;YAAI,IAAA,CAAA,GAAA,IAAA;YAMpB,I;;YANoB,C,CAAA,I,EAAA,C,GAAA,CAAA,CAAA,IAAA,CAAA,IAAA,C,EACpBmB,KAAKC,SAALD,GACI,YAAA,OAAmB9B,CAAAA,CAAO+B,SAA1B,GACMC,QAAAA,CAASC,aAATD,CAAuBhC,CAAAA,CAAO+B,SAA9BC,CADN,GAEMhC,CAAAA,CAAO+B,S,EAAAA,CAEZD,KAAKC,SAAV,EACI,MAAM,IAAIG,KAAJ,CAAU,sCAAV,CAAN;YAGJJ,KAAKlB,UAALkB,GAAkBnB,CAAlBmB,EACAA,KAAKK,IAALL,GAAYnB,CAAAA,CAAGwB,IADfL,EAEAA,KAAK9B,MAAL8B,GAAcM,MAAAA,CAAOC,MAAPD,CACV,EADUA,EAEV;cACIE,MAAAA,EAAQ,EADZ;cAEIC,kBAAAA,EAAoB,EAFxB;cAGIC,YAAAA,EAAc,CAHlB;cAIIC,mBAAAA,EAAqB,SAJzB;cAKIC,YAAAA,EAAc,MALlB;cAMIC,cAAAA,EAAgB,SANpB;cAOIC,gBAAAA,EAAkB,MAPtB;cAQIC,kBAAAA,EAAoB,MARxB;cASIC,UAAAA,EAAY,OAThB;cAUIC,QAAAA,EAAU,EAVd;cAWIC,QAAAA,EAAU,IAXd;cAYIC,YAAAA,EAAAA,CAAc,CAZlB;cAaIC,kBAAAA,EAAoBpB,KAAKqB,yBAb7B;cAcIC,YAAAA,EAActB,KAAKuB,mBAdvB;cAeIC,oBAAAA,EAAsBxB,KAAKyB,2BAf/B;cAgBIC,sBAAAA,EAAwB1B,KAAK2B,6BAhBjC;cAiBIC,MAAAA,EAAQ;YAjBZ,CAFUtB,EAqBVpC,CArBUoC,CAFdN,EA0BAA,KAAK6B,QAAL7B,GAAgB,EA1BhBA,EA2BAA,KAAKzB,OAALyB,GAAe,IA3BfA,EA4BAA,KAAKxB,MAALwB,GAAc,IA5BdA,EA6BAA,KAAKjB,UAALiB,GAAkB,IA7BlBA,EA8BAA,KAAKhB,cAALgB,GAAsB,IA9BtBA,EA+BAA,KAAKd,qBAALc,GAA6B,IA/B7BA,EAyCAA,KAAKT,OAALS,GAAeA,KAAK9B,MAAL8B,CAAYmB,YAAZnB,GACTA,KAAKlB,UAALkB,CAAgBK,IAAhBL,CAAqB8B,QAArB9B,CACE,YAAA;cAAA,OAAM,CAAA,CAAKrB,MAAL,EAAN;YAAWA,CADbqB,EAEEA,KAAK9B,MAAL8B,CAAYmB,YAFdnB,CADSA,GAKT,YAAA;cAAA,OAAM,CAAA,CAAKrB,MAAL,EAAN;YAAWA,CA9CjBqB;;;;;;mBAjEJ,UAAc9B,CAAd,EAAcA;cACV,OAAO;gBACHC,IAAAA,EAAM,UADH;gBAEHC,SAAAA,EAAAA,EAAAA,CAAWF,CAAXE,IAAWF,CAAUA,CAAAA,CAAOE,SAA5BA,KAAwCF,CAAAA,CAAOE,SAF5C;gBAGHF,MAAAA,EAAQA,CAHL;gBAIHG,QAAAA,EAAUJ;cAJP,CAAP;YAIcA;cAAAA,C;;mBAgHlB,YAAA;cAEQ+B,KAAKlB,UAALkB,CAAgB+B,OAAhB/B,GACAA,KAAKpB,QAALoB,EADAA,GAGAA,KAAKlB,UAALkB,CAAgBgC,IAAhBhC,CAAqB,OAArBA,EAA8BA,KAAKpB,QAAnCoB,CAHAA;YAGmCpB;;;mBAO3C,YAAA;cACIoB,KAAKiC,KAALjC,IACAA,KAAKlB,UAALkB,CAAgBkC,EAAhBlC,CAAmB,QAAnBA,EAA6BA,KAAKtB,SAAlCsB,CADAA,EAEAA,KAAKlB,UAALkB,CAAgBkC,EAAhBlC,CAAmB,MAAnBA,EAA2BA,KAAKT,OAAhCS,CAFAA,EAGAA,KAAKlB,UAALkB,CAAgBkC,EAAhBlC,CAAmB,OAAnBA,EAA4BA,KAAKpB,QAAjCoB,CAHAA,EAIAA,KAAKlB,UAALkB,CAAgBxB,MAAhBwB,CAAuBzB,OAAvByB,CAA+BmC,mBAA/BnC,CACI,QADJA,EAEIA,KAAK1B,SAFT0B,CAJAA,EAQIA,KAAKzB,OAALyB,IAAgBA,KAAKzB,OAALyB,CAAaoC,UAA7BpC,KACAA,KAAKzB,OAALyB,CAAamC,mBAAbnC,CAAiC,OAAjCA,EAA0CA,KAAKR,eAA/CQ,GACAA,KAAKzB,OAALyB,CAAaoC,UAAbpC,CAAwBqC,WAAxBrC,CAAoCA,KAAKzB,OAAzCyB,CADAA,EAEAA,KAAKzB,OAALyB,GAAe,IAHfA,CARJA;YAWmB;;;mBAQvB,YAAA;cACI,IAAMsC,CAAAA,GAAWtC,KAAKlB,UAALkB,CAAgB9B,MAAjC;cACA8B,KAAKC,SAALD,CAAeuC,SAAfvC,GAA2B,EAA3BA,EACAA,KAAKzB,OAALyB,GAAeA,KAAKC,SAALD,CAAewC,WAAfxC,CACXE,QAAAA,CAASuC,aAATvC,CAAuB,UAAvBA,CADWF,CADfA,EAIAA,KAAKK,IAALL,CAAU0C,KAAV1C,CAAgBA,KAAKzB,OAArByB,EAA8B;gBAC1B2C,OAAAA,EAAS,OADiB;gBAE1BC,QAAAA,EAAU,UAFgB;gBAG1BC,UAAAA,EAAY,MAHc;gBAI1BC,gBAAAA,EAAkB,MAJQ;gBAK1BtC,MAAAA,EAAQ,GAAF,MAAE,CAAGR,KAAK9B,MAAL8B,CAAYQ,MAAf,EAAF,IAAE;cALkB,CAA9BR,CAJAA,EASU,CAGNsC,CAAAA,CAASS,UAATT,IAAuBA,CAAAA,CAASU,YAH1B,KAINhD,KAAKK,IAALL,CAAU0C,KAAV1C,CAAgBA,KAAKzB,OAArByB,EAA8B;gBAC1Bf,KAAAA,EAAO,MADmB;gBAE1BgE,SAAAA,EAAW,QAFe;gBAG1BC,SAAAA,EAAW;cAHe,CAA9BlD,CAbJA,EAoBAA,KAAKzB,OAALyB,CAAaX,gBAAbW,CAA8B,OAA9BA,EAAuCA,KAAKR,eAA5CQ,CApBAA;YAoB4CR;;;mBAOhD,YAAA;cACSQ,KAAKzB,OAALyB,IACDA,KAAKmD,aAALnD,EADCA,EAGLA,KAAKoD,cAALpD,EAHKA,EAILA,KAAKqD,yBAALrD,EAJKA,EAKLA,KAAKsD,cAALtD,EALKA;YAKAsD;;;mBAOT,YAAA;cACI,IAAMC,CAAAA,GAASvD,KAAKzB,OAALyB,CAAawC,WAAbxC,CACXE,QAAAA,CAASuC,aAATvC,CAAuB,QAAvBA,CADWF,CAAf;cAGAA,KAAK6B,QAAL7B,CAAcwD,IAAdxD,CAAmBuD,CAAnBvD,GACAA,KAAKK,IAALL,CAAU0C,KAAV1C,CAAgBuD,CAAhBvD,EAAwB;gBACpB4C,QAAAA,EAAU,UADU;gBAEpBa,MAAAA,EAAQ;cAFY,CAAxBzD,CADAA;YAGY;;;mBAQhB,YAAA;cACI,IAAMuD,CAAAA,GAASvD,KAAK6B,QAAL7B,CAAc0D,GAAd1D,EAAf;cACAuD,CAAAA,CAAOI,aAAPJ,CAAqBlB,WAArBkB,CAAiCA,CAAjCA;YAAiCA;;;mBAQrC,YAAA;cAMI,KALA,IAAMK,CAAAA,GAAazE,IAAAA,CAAKC,KAALD,CAAWa,KAAKxB,MAALwB,CAAYzB,OAAZyB,CAAoBD,WAA/BZ,CAAnB,EACM0E,CAAAA,GAAmB1E,IAAAA,CAAK2E,IAAL3E,CACrByE,CAAAA,GAAa5D,KAAKd,qBADGC,CAIzB,EAAOa,KAAK6B,QAAL7B,CAAc+D,MAAd/D,GAAuB6D,CAA9B,GACI7D,KAAKgE,SAALhE;;cAGJ,OAAOA,KAAK6B,QAAL7B,CAAc+D,MAAd/D,GAAuB6D,CAA9B,GACI7D,KAAKiE,YAALjE;YAAKiE;;;mBAQb,YAAA;cAA4B,IAAA,CAAA,GAAA,IAAA;cAAA,IAElBC,CAAAA,GAAiBlE,KAAK6B,QAAL7B,CAAc+D,MAFb;cAGxB/D,KAAK6B,QAAL7B,CAAcmE,OAAdnE,CAAsB,UAACuD,CAAD,EAASa,CAAT,EAASA;gBAG3B,IAAMC,CAAAA,GACFD,CAAAA,KAAMF,CAAAA,GAAiB,CAAvBE,GACM,CAAA,CAAK5F,MAAL,CAAYD,OAAZ,CAAoBwB,WAApB,GACA,CAAA,CAAKb,qBAAL,IAA8BgF,CAAAA,GAAiB,CAA/C,CAFNE,GAGM,CAAA,CAAKlF,qBAJf;gBAMAqE,CAAAA,CAAOtE,KAAPsE,GAAec,CAAAA,GAAc,CAAA,CAAKtF,UAAlCwE,EAGAA,CAAAA,CAAO/C,MAAP+C,GAAO/C,CAAU,CAAA,CAAKtC,MAAL,CAAYsC,MAAZ,GAAqB,CAA/BA,IAAoC,CAAA,CAAKzB,UAHhDwE,EAIA,CAAA,CAAKlD,IAAL,CAAUqC,KAAV,CAAgBa,CAAhB,EAAwB;kBACpBtE,KAAAA,EAAO,GAAF,MAAE,CAAGoF,CAAH,EAAF,IAAE,CADa;kBAEpB7D,MAAAA,EAAQ,GAAF,MAAE,CAAG,CAAA,CAAKtC,MAAL,CAAYsC,MAAf,EAAF,IAAE,CAFY;kBAGpB8D,IAAAA,EAAM,GAAF,MAAE,CAAGF,CAAAA,GAAI,CAAA,CAAKlF,qBAAZ,EAAF,IAAE;gBAHc,CAAxB,CAJAqE;cAOQ,CAhBZvD;YAgBY;;;mBAShB,YAAA;cAAiB,IAAA,CAAA,GAAA,IAAA;cAAA,IACPkB,CAAAA,GACFlB,KAAK9B,MAAL8B,CAAYkB,QAAZlB,IACAA,KAAKlB,UAALkB,CAAgBuE,OAAhBvE,CAAwBwE,WAAxBxE,EAHS;;cAKb,IAAA,EAAIkB,CAAAA,IAAY,CAAhB,CAAA,EAAA;gBAGA,IA6BIkD,CA7BJ;gBAAA,IAAM9B,CAAAA,GAAWtC,KAAKlB,UAALkB,CAAgB9B,MAAjC;gBAAA,IACM+C,CAAAA,GAAWjB,KAAK9B,MAAL8B,CAAYiB,QAAZjB,GAAuBsC,CAAAA,CAASvD,UADjD;gBAAA,IAEM0F,CAAAA,GAAeC,QAAAA,CAASxD,CAATwD,EAAmB,EAAnBA,CAAAA,GAAyB,CAF9C;gBAAA,IAGMzF,CAAAA,GACFqD,CAAAA,CAASS,UAATT,IAASS,CAAeT,CAAAA,CAASU,YAAjCV,GACMtC,KAAKxB,MAALwB,CAAY2E,QAAZ3E,EADNsC,GAEMtC,KAAKxB,MAALwB,CAAYzB,OAAZyB,CAAoBD,WAApBC,GAAkCsC,CAAAA,CAASvD,UANrD;gBAAA,IAOM6F,CAAAA,GAAU5E,KAAK9B,MAAL8B,CAAYQ,MAAZR,GAAqBA,KAAKjB,UAP1C;gBAAA,IAQM8F,CAAAA,GACF7E,KAAK9B,MAAL8B,CAAYQ,MAAZR,IACCA,KAAK9B,MAAL8B,CAAYS,kBAAZT,GAAiC,GADlCA,IAEAA,KAAKjB,UAXT;gBAAA,IAYM+F,CAAAA,GAAkB7F,CAAAA,GAAQiC,CAZhC;gBAAA,IAcM6D,CAAAA,GAAa/E,KAAK9B,MAAL8B,CAAYoB,kBAd/B;gBAAA,IAiBM4D,CAAAA,GAAkB,UAAA,CAAA,EAAA;kBAAM,OACR,cAAA,OAAXC,CAAW,GAAaA,CAAAA,CAAOH,CAAPG,CAAb,GAAuCA,CAD/B;gBAC+BA,CAlB7D;gBAAA,IAmBM3D,CAAAA,GAAe0D,CAAAA,CAAgBhF,KAAK9B,MAAL8B,CAAYsB,YAA5B0D,CAnBrB;gBAAA,IAoBMxD,CAAAA,GAAuBwD,CAAAA,CACzBhF,KAAK9B,MAAL8B,CAAYwB,oBADawD,CApB7B;gBAAA,IAuBMtD,CAAAA,GAAyBsD,CAAAA,CAC3BhF,KAAK9B,MAAL8B,CAAY0B,sBADesD,CAvB/B;gBAAA,IA2BIE,CAAAA,GAAWJ,CAAAA,GAAkB9E,KAAK9B,MAAL8B,CAAY4B,MA3B7C;gBAAA,IA4BIuD,CAAAA,GAAa,CA5BjB;gBAAA,IAgCMC,CAAAA,GAAc,EAhCpB;;gBAiCA,KAAKhB,CAAAA,GAAI,CAAT,EAAYA,CAAAA,GAAIK,CAAAA,GAAenD,CAA/B,EAA6C8C,CAAAA,EAA7C,EACIgB,CAAAA,CAAY5B,IAAZ4B,CAAiB,CAAChB,CAAD,EAAIe,CAAJ,EAAgBD,CAAhB,CAAjBE,GACAD,CAAAA,IAAc7D,CADd8D,EAEAF,CAAAA,IAAYJ,CAAAA,GAAkBxD,CAF9B8D;;gBAMJ,IAAMC,CAAAA,GAAkB,UAAA,CAAA,EAAA;kBACpBD,CAAAA,CAAYjB,OAAZiB,CAAoB,UAAA,CAAA,EAAA;oBAChBE,CAAAA,CAAGC,CAAAA,CAAI,CAAJA,CAAHD,EAAWC,CAAAA,CAAI,CAAJA,CAAXD,EAAmBC,CAAAA,CAAI,CAAJA,CAAnBD,CAAAA;kBAAuB,CAD3BF;gBAC2B,CAF/B;;gBAOApF,KAAKwF,aAALxF,CAAmBA,KAAK9B,MAAL8B,CAAYY,YAA/BZ,GACAA,KAAKyF,QAALzF,CAAAA,GAAAA,MAAAA,CAAiBiB,CAAjBjB,EAAAA,KAAAA,EAAAA,MAAAA,CAA+BA,KAAK9B,MAAL8B,CAAYgB,UAA3ChB,CAAAA,CADAA,EAEAA,KAAKwF,aAALxF,CAAmBA,KAAK9B,MAAL8B,CAAYc,gBAA/Bd,CAFAA,EAGAqF,CAAAA,CAAgB,UAACjB,CAAD,EAAIe,CAAJ,EAAgBD,CAAhB,EAAgBA;kBACxBd,CAAAA,GAAI5C,CAAJ4C,IAA6B,CAA7BA,KACA,CAAA,CAAKsB,QAAL,CAAcR,CAAd,EAAwB,CAAxB,EAA2B,CAA3B,EAA8BN,CAA9B,GACA,CAAA,CAAKe,QAAL,CACIZ,CAAAA,CAAWI,CAAXJ,EAAuBD,CAAvBC,CADJ,EAEIG,CAAAA,GAAW,CAAA,CAAKhH,MAAL,CAAYwC,YAAZ,GAA2B,CAAA,CAAK3B,UAF/C,EAGI6F,CAHJ,CAFAR;gBAKIQ,CANZS,CAHArF,EAeAA,KAAKwF,aAALxF,CAAmBA,KAAK9B,MAAL8B,CAAYa,cAA/Bb,CAfAA,EAgBAA,KAAKyF,QAALzF,CAAAA,GAAAA,MAAAA,CAAiBiB,CAAjBjB,EAAAA,KAAAA,EAAAA,MAAAA,CAA+BA,KAAK9B,MAAL8B,CAAYgB,UAA3ChB,CAAAA,CAhBAA,EAiBAA,KAAKwF,aAALxF,CAAmBA,KAAK9B,MAAL8B,CAAYe,kBAA/Bf,CAjBAA,EAkBAqF,CAAAA,CAAgB,UAACjB,CAAD,EAAIe,CAAJ,EAAgBD,CAAhB,EAAgBA;kBACxBd,CAAAA,GAAI1C,CAAJ0C,IAA+B,CAA/BA,KACA,CAAA,CAAKsB,QAAL,CAAcR,CAAd,EAAwB,CAAxB,EAA2B,CAA3B,EAA8BN,CAA9B,GACA,CAAA,CAAKe,QAAL,CACIZ,CAAAA,CAAWI,CAAXJ,EAAuBD,CAAvBC,CADJ,EAEIG,CAAAA,GAAW,CAAA,CAAKhH,MAAL,CAAYwC,YAAZ,GAA2B,CAAA,CAAK3B,UAF/C,EAGI6F,CAHJ,CAFAR;gBAKIQ,CANZS,CAlBArF,EA8BAA,KAAKwF,aAALxF,CAAmBA,KAAK9B,MAAL8B,CAAYW,mBAA/BX,CA9BAA,EA+BAqF,CAAAA,CAAgB,UAACjB,CAAD,EAAIe,CAAJ,EAAgBD,CAAhB,EAAgBA;kBAExBd,CAAAA,GAAI1C,CAAJ0C,IAA+B,CAA/BA,IACAA,CAAAA,GAAI5C,CAAJ4C,IAA6B,CAD7BA,IAGA,CAAA,CAAKsB,QAAL,CAAcR,CAAd,EAAwB,CAAxB,EAA2B,CAA3B,EAA8BL,CAA9B,CAHAT;gBAG8BS,CALtCQ,CA/BArF;cAoCsC6E;YAAAA;;;mBAW1C,UAAce,CAAd,EAAcA;cACV5F,KAAK6B,QAAL7B,CAAcmE,OAAdnE,CAAsB,UAAA,CAAA,EAAA;gBAClB,IAAM6F,CAAAA,GAAUtC,CAAAA,CAAOuC,UAAPvC,CAAkB,IAAlBA,CAAhB;gBACIsC,CAAAA,KACAA,CAAAA,CAAQD,SAARC,GAAoBD,CADpBC,CAAAA;cACoBD,CAH5B5F;YAG4B4F;;;mBAUhC,UAASG,CAAT,EAASA;cACL/F,KAAK6B,QAAL7B,CAAcmE,OAAdnE,CAAsB,UAAA,CAAA,EAAA;gBAClB,IAAM6F,CAAAA,GAAUtC,CAAAA,CAAOuC,UAAPvC,CAAkB,IAAlBA,CAAhB;gBACIsC,CAAAA,KACAA,CAAAA,CAAQE,IAARF,GAAeE,CADfF,CAAAA;cACeE,CAHvB/F;YAGuB+F;;;mBAe3B,UAASC,CAAT,EAAYC,CAAZ,EAAehH,CAAf,EAAsBuB,CAAtB,EAAsBA;cAAQ,IAAA,CAAA,GAAA,IAAA;cAC1BR,KAAK6B,QAAL7B,CAAcmE,OAAdnE,CAAsB,UAACuD,CAAD,EAASa,CAAT,EAASA;gBAC3B,IAAM8B,CAAAA,GAAa9B,CAAAA,GAAI,CAAA,CAAKpF,cAA5B;gBAAA,IAEMmH,CAAAA,GAAe;kBACjBC,EAAAA,EAAIjH,IAAAA,CAAKkH,GAALlH,CAAS6G,CAAT7G,EAAYiF,CAAAA,GAAI,CAAA,CAAKpF,cAArBG,CADa;kBAEjBmH,EAAAA,EAAIL,CAFa;kBAGjBM,EAAAA,EAAIpH,IAAAA,CAAKqH,GAALrH,CAAS6G,CAAAA,GAAI/G,CAAbE,EAAoBiF,CAAAA,GAAI,CAAA,CAAKpF,cAAToF,GAA0Bb,CAAAA,CAAOtE,KAArDE,CAHa;kBAIjBsH,EAAAA,EAAIR,CAAAA,GAAIzF;gBAJS,CAFrB;;gBASA,IAAI2F,CAAAA,CAAaC,EAAbD,GAAkBA,CAAAA,CAAaI,EAAnC,EAAuC;kBACnC,IAAMV,CAAAA,GAAUtC,CAAAA,CACXuC,UADWvC,CACA,IADAA,CAAhB;kBAEIsC,CAAAA,IACAA,CAAAA,CACKH,QADLG,CAEQM,CAAAA,CAAaC,EAAbD,GAAkBD,CAF1BL,EAGQM,CAAAA,CAAaG,EAHrBT,EAIQM,CAAAA,CAAaI,EAAbJ,GAAkBA,CAAAA,CAAaC,EAJvCP,EAKQM,CAAAA,CAAaM,EAAbN,GAAkBA,CAAAA,CAAaG,EALvCT,CADAA;gBAMuCS;cAAAA,CAnBnDtG;YAmBmDsG;;;mBAcvD,UAASI,CAAT,EAAeV,CAAf,EAAkBC,CAAlB,EAAkBA;cACd,IAAIU,CAAJ;cAAA,IACIC,CAAAA,GAAU,CADd;cAGA5G,KAAK6B,QAAL7B,CAAcmE,OAAdnE,CAAsB,UAAA,CAAA,EAAA;gBAClB,IAAM6F,CAAAA,GAAUtC,CAAAA,CAAOuC,UAAPvC,CAAkB,IAAlBA,CAAhB;;gBACA,IAAIsC,CAAJ,EAAa;kBACT,IAAMxB,CAAAA,GAAcwB,CAAAA,CAAQtC,MAARsC,CAAe5G,KAAnC;kBAEA,IAAI2H,CAAAA,GAAUZ,CAAAA,GAAIW,CAAlB,EACI;kBAGAC,CAAAA,GAAUvC,CAAVuC,GAAwBZ,CAAxBY,IAA6Bf,CAA7Be,KACAD,CAAAA,GAAYd,CAAAA,CAAQgB,WAARhB,CAAoBa,CAApBb,EAA0B5G,KAAtC0H,EACAd,CAAAA,CAAQF,QAARE,CAAiBa,CAAjBb,EAAuBG,CAAAA,GAAIY,CAA3Bf,EAAoCI,CAApCJ,CAFAe,GAKJA,CAAAA,IAAWvC,CALPuC;gBAKOvC;cAAAA,CAdnBrE;YAcmBqE;;;mBAYvB,UAA0ByC,CAA1B,EAAmCC,CAAnC,EAAmCA;cAC/B,IAAID,CAAAA,GAAU,EAAVA,GAAe,CAAnB,EAAsB;gBAElB,IAAME,CAAAA,GAAUtC,QAAAA,CAASoC,CAAAA,GAAU,EAAnBpC,EAAuB,EAAvBA,CAAhB;gBAIA,OADAoC,CAAAA,GAAAA,CAFAA,CAAAA,GAAUpC,QAAAA,CAASoC,CAAAA,GAAU,EAAnBpC,EAAuB,EAAvBA,CAEVoC,IAAoB,EAApBA,GAAyB,MAAMA,CAA/BA,GAAyCA,CAAzCA,EACA,GAAA,MAAA,CAAUE,CAAV,EAAA,GAAA,EAAA,MAAA,CAAqBF,CAArB,CAAA;cAEJ;;cAAA,OAAO3H,IAAAA,CAAKC,KAALD,CAAqB,MAAV2H,CAAX3H,IAA6B,GAApC;YAAoC;;;mBASxC,UAAoB4H,CAApB,EAAoBA;cAChB,OAAIA,CAAAA,IAAY,EAAZA,GACO,CADPA,GAEkB,IAAXA,CAAW,IAAK,EAAL,GACX,CADW,GAEA,KAAXA,CAAW,IAAM,EAAN,GACX,EADW,GAGa,KAA5B5H,IAAAA,CAAK2E,IAAL3E,CAAU,KAAM4H,CAAhB5H,CAPP;YAOuB4H;;;mBAS3B,UAA4BA,CAA5B,EAA4BA;cACxB,OAAIA,CAAAA,IAAY,EAAZA,GACO,EADPA,GAEkB,IAAXA,CAAW,IAAK,EAAL,GACX,CADW,GAGX,CALX;YAKW;;;mBAWf,UAA8BA,CAA9B,EAA8BA;cAC1B,OAAIA,CAAAA,IAAY,EAAZA,GACO,CADPA,GAGO,CAHX;YAGW;YAjgBG9I,K;QAfDA,CAAAA,E;;;;;;eAoBjBK,S,GAAY,YAAA;YACJ,CAAA,CAAKC,OAAL,IAAgB,CAAA,CAAKC,MAAL,CAAYD,OAA5B,KACA,CAAA,CAAKA,OAAL,CAAaE,UAAb,GAA0B,CAAA,CAAKD,MAAL,CAAYD,OAAZ,CAAoBE,UAD9C;UAC8CA,C,OAOtDC,S,GAAY,YAAA;YAAA,OAAM,CAAA,CAAKC,MAAL,EAAN;UAAWA,C,OAEvBC,Q,GAAW,YAAA;YACP,IAAMC,CAAAA,GAAK,CAAA,CAAKC,UAAhB;YACA,CAAA,CAAKN,MAAL,GAAcK,CAAAA,CAAGL,MAAjB,EACA,CAAA,CAAKO,UAAL,GAAkBF,CAAAA,CAAGL,MAAHK,CAAUX,MAAVW,CAAiBE,UADnC,EAEA,CAAA,CAAKC,cAAL,GAAsBH,CAAAA,CAAGL,MAAHK,CAAUG,cAAVH,IAA4BA,CAAAA,CAAGL,MAAHK,CAAUI,KAF5D,EAGA,CAAA,CAAKC,qBAAL,GACIL,CAAAA,CAAGL,MAAHK,CAAUK,qBAAVL,IACAM,IAAAA,CAAKC,KAALD,CAAW,CAAA,CAAKH,cAAL,GAAsB,CAAA,CAAKD,UAAtCI,CALJ,EAQAN,CAAAA,CAAGL,MAAHK,CAAUN,OAAVM,CAAkBQ,gBAAlBR,CAAmC,QAAnCA,EAA6C,CAAA,CAAKP,SAAlDO,CARA,EASAA,CAAAA,CAAGS,EAAHT,CAAM,QAANA,EAAgB,CAAA,CAAKH,SAArBG,CATA,EAUAA,CAAAA,CAAGS,EAAHT,CAAM,MAANA,EAAc,CAAA,CAAKU,OAAnBV,CAVA,EAYA,CAAA,CAAKF,MAAL,EAZA;UAYKA,C,OAMTa,e,GAAkB,UAAA,CAAA,EAAA;YACdC,CAAAA,CAAEC,cAAFD;YACA,IAAME,CAAAA,GAAO,aAAaF,CAAb,GAAiBA,CAAAA,CAAEG,OAAnB,GAA6BH,CAAAA,CAAEI,MAA5C;YACA,CAAA,CAAKC,SAAL,CAAe,OAAf,EAAwBH,CAAAA,GAAO,CAAA,CAAKpB,OAAL,CAAawB,WAApBJ,IAAmC,CAA3D;UAA2D,C;QAAA,C;;;;;QChH/DsH,CAAAA,GAA2B,E;WAG/B,SAASC,CAAT,CAA6BC,CAA7B,EAA6BA;MAE5B,IAAIC,CAAAA,GAAeH,CAAAA,CAAyBE,CAAzBF,CAAnB;MACA,IAAA,KAAqBI,CAArB,KAAID,CAAJ,EACC,OAAOA,CAAAA,CAAaxJ,OAApB;MAGD,IAAIC,CAAAA,GAASoJ,CAAAA,CAAyBE,CAAzBF,CAAAA,GAAqC;QAGjDrJ,OAAAA,EAAS;MAHwC,CAAlD;MAUA,OAHA0J,CAAAA,CAAoBH,CAApBG,CAAAA,CAA8BzJ,CAA9ByJ,EAAsCzJ,CAAAA,CAAOD,OAA7C0J,EAAsDJ,CAAtDI,GAGOzJ,CAAAA,CAAOD,OAAd;IClByBsJ,CDC1B,CCD8C,GDC9C,C;EFMA,CAAA,GAAA;AAAA,CAVA,C","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(self, function() {\nreturn ","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} unlabeledNotchColor='#c0c0c0' The colour of the notches\n * that do not have labels\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {?number} duration Length of the track in seconds. Overrides\n * getDuration() for setting length of timeline\n * @property {function} formatTimeCallback (sec, pxPerSec) -> label\n * @property {function} timeInterval (pxPerSec) -> seconds between notches\n * @property {function} primaryLabelInterval (pxPerSec) -> cadence between\n * labels in primary color\n * @property {function} secondaryLabelInterval (pxPerSec) -> cadence between\n * labels in secondary color\n * @property {?number} offset Offset for the timeline start in seconds. May also be\n * negative.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    // event handlers\n    _onScroll = () => {\n        if (this.wrapper && this.drawer.wrapper) {\n            this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n        }\n    };\n\n    /**\n     * @returns {void}\n     */\n    _onRedraw = () => this.render();\n\n    _onReady = () => {\n        const ws = this.wavesurfer;\n        this.drawer = ws.drawer;\n        this.pixelRatio = ws.drawer.params.pixelRatio;\n        this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n        this.maxCanvasElementWidth =\n            ws.drawer.maxCanvasElementWidth ||\n            Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n        // add listeners\n        ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n        ws.on('redraw', this._onRedraw);\n        ws.on('zoom', this._onZoom);\n\n        this.render();\n    };\n\n    /**\n     * @param {object} e Click event\n     */\n    _onWrapperClick = e => {\n        e.preventDefault();\n        const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n        this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n    };\n\n    /**\n     * Creates an instance of TimelinePlugin.\n     *\n     * You probably want to use TimelinePlugin.create()\n     *\n     * @param {TimelinePluginParams} params Plugin parameters\n     * @param {object} ws Wavesurfer instance\n     */\n    constructor(params, ws) {\n        this.container =\n            'string' == typeof params.container\n                ? document.querySelector(params.container)\n                : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n\n        this.wavesurfer = ws;\n        this.util = ws.util;\n        this.params = Object.assign(\n            {},\n            {\n                height: 20,\n                notchPercentHeight: 90,\n                labelPadding: 5,\n                unlabeledNotchColor: '#c0c0c0',\n                primaryColor: '#000',\n                secondaryColor: '#c0c0c0',\n                primaryFontColor: '#000',\n                secondaryFontColor: '#000',\n                fontFamily: 'Arial',\n                fontSize: 10,\n                duration: null,\n                zoomDebounce: false,\n                formatTimeCallback: this.defaultFormatTimeCallback,\n                timeInterval: this.defaultTimeInterval,\n                primaryLabelInterval: this.defaultPrimaryLabelInterval,\n                secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n                offset: 0\n            },\n            params\n        );\n\n        this.canvases = [];\n        this.wrapper = null;\n        this.drawer = null;\n        this.pixelRatio = null;\n        this.maxCanvasWidth = null;\n        this.maxCanvasElementWidth = null;\n        /**\n         * This event handler has to be in the constructor function because it\n         * relies on the debounce function which is only available after\n         * instantiation\n         *\n         * Use a debounced function if `params.zoomDebounce` is defined\n         *\n         * @returns {void}\n         */\n        this._onZoom = this.params.zoomDebounce\n            ? this.wavesurfer.util.debounce(\n                () => this.render(),\n                this.params.zoomDebounce\n            )\n            : () => this.render();\n    }\n\n    /**\n     * Initialisation function used by the plugin API\n     */\n    init() {\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        } else {\n            this.wavesurfer.once('ready', this._onReady);\n        }\n    }\n\n    /**\n     * Destroy function used by the plugin API\n     */\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('zoom', this._onZoom);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener(\n            'scroll',\n            this._onScroll\n        );\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.removeEventListener('click', this._onWrapperClick);\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    /**\n     * Create a timeline element to wrap the canvases drawn by this plugin\n     *\n     */\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.container.innerHTML = '';\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n\n    /**\n     * Render the timeline (also updates the already rendered timeline)\n     *\n     */\n    render() {\n        if (!this.wrapper) {\n            this.createWrapper();\n        }\n        this.updateCanvases();\n        this.updateCanvasesPositioning();\n        this.renderCanvases();\n    }\n\n    /**\n     * Add new timeline canvas\n     *\n     */\n    addCanvas() {\n        const canvas = this.wrapper.appendChild(\n            document.createElement('canvas')\n        );\n        this.canvases.push(canvas);\n        this.util.style(canvas, {\n            position: 'absolute',\n            zIndex: 4\n        });\n    }\n\n    /**\n     * Remove timeline canvas\n     *\n     */\n    removeCanvas() {\n        const canvas = this.canvases.pop();\n        canvas.parentElement.removeChild(canvas);\n    }\n\n    /**\n     * Make sure the correct of timeline canvas elements exist and are cached in\n     * this.canvases\n     *\n     */\n    updateCanvases() {\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(\n            totalWidth / this.maxCanvasElementWidth\n        );\n\n        while (this.canvases.length < requiredCanvases) {\n            this.addCanvas();\n        }\n\n        while (this.canvases.length > requiredCanvases) {\n            this.removeCanvas();\n        }\n    }\n\n    /**\n     * Update the dimensions and positioning style for all the timeline canvases\n     *\n     */\n    updateCanvasesPositioning() {\n        // cache length for performance\n        const canvasesLength = this.canvases.length;\n        this.canvases.forEach((canvas, i) => {\n            // canvas width is the max element width, or if it is the last the\n            // required width\n            const canvasWidth =\n                i === canvasesLength - 1\n                    ? this.drawer.wrapper.scrollWidth -\n                      this.maxCanvasElementWidth * (canvasesLength - 1)\n                    : this.maxCanvasElementWidth;\n            // set dimensions and style\n            canvas.width = canvasWidth * this.pixelRatio;\n            // on certain pixel ratios the canvas appears cut off at the bottom,\n            // therefore leave 1px extra\n            canvas.height = (this.params.height + 1) * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        });\n    }\n\n    /**\n     * Render the timeline labels and notches\n     *\n     */\n    renderCanvases() {\n        const duration =\n            this.params.duration ||\n            this.wavesurfer.backend.getDuration();\n\n        if (duration <= 0) {\n            return;\n        }\n        const wsParams = this.wavesurfer.params;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width =\n            wsParams.fillParent && !wsParams.scrollParent\n                ? this.drawer.getWidth()\n                : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const height1 = this.params.height * this.pixelRatio;\n        const height2 =\n            this.params.height *\n            (this.params.notchPercentHeight / 100) *\n            this.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option =>\n            typeof option === 'function' ? option(pixelsPerSecond) : option;\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(\n            this.params.primaryLabelInterval\n        );\n        const secondaryLabelInterval = intervalFnOrVal(\n            this.params.secondaryLabelInterval\n        );\n\n        let curPixel = pixelsPerSecond * this.params.offset;\n        let curSeconds = 0;\n        let i;\n        // build an array of position data with index, second and pixel data,\n        // this is then used multiple times below\n        const positioning = [];\n        for (i = 0; i < totalSeconds / timeInterval; i++) {\n            positioning.push([i, curSeconds, curPixel]);\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n\n        // iterate over each position\n        const renderPositions = cb => {\n            positioning.forEach(pos => {\n                cb(pos[0], pos[1], pos[2]);\n            });\n        };\n\n        // render primary labels\n        this.setFillStyles(this.params.primaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.primaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % primaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render secondary labels\n        this.setFillStyles(this.params.secondaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.secondaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % secondaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds, pixelsPerSecond),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render the actual notches (when no labels are used)\n        this.setFillStyles(this.params.unlabeledNotchColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (\n                i % secondaryLabelInterval !== 0 &&\n                i % primaryLabelInterval !== 0\n            ) {\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n        });\n    }\n\n    /**\n     * Set the canvas fill style\n     *\n     * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n     * use\n     */\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.fillStyle = fillStyle;\n            }\n        });\n    }\n\n    /**\n     * Set the canvas font\n     *\n     * @param {DOMString} font Font to use\n     */\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                context.font = font;\n            }\n        });\n    }\n\n    /**\n     * Draw a rectangle on the canvases\n     *\n     * (it figures out the offset for each canvas)\n     *\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     * @param {number} width Width\n     * @param {number} height Height\n     */\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                const context = canvas\n                    .getContext('2d');\n                if (context) {\n                    context\n                        .fillRect(\n                            intersection.x1 - leftOffset,\n                            intersection.y1,\n                            intersection.x2 - intersection.x1,\n                            intersection.y2 - intersection.y1\n                        );\n                }\n            }\n        });\n    }\n\n    /**\n     * Fill a given text on the canvases\n     *\n     * @param {string} text Text to render\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     */\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            if (context) {\n                const canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    return;\n                }\n\n                if (xOffset + canvasWidth > x && context) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            }\n        });\n    }\n\n    /**\n     * Turn the time into a suitable label for the time.\n     *\n     * @param {number} seconds Seconds to format\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultFormatTimeCallback(seconds, pxPerSec) {\n        if (seconds / 60 > 1) {\n            // calculate minutes and seconds from seconds count\n            const minutes = parseInt(seconds / 60, 10);\n            seconds = parseInt(seconds % 60, 10);\n            // fill up seconds with zeroes\n            seconds = seconds < 10 ? '0' + seconds : seconds;\n            return `${minutes}:${seconds}`;\n        }\n        return Math.round(seconds * 1000) / 1000;\n    }\n\n    /**\n     * Return how many seconds should be between each notch\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n    defaultTimeInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 1;\n        } else if (pxPerSec * 5 >= 25) {\n            return 5;\n        } else if (pxPerSec * 15 >= 25) {\n            return 15;\n        }\n        return Math.ceil(0.5 / pxPerSec) * 60;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the primary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultPrimaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 10;\n        } else if (pxPerSec * 5 >= 25) {\n            return 6;\n        } else if (pxPerSec * 15 >= 25) {\n            return 4;\n        }\n        return 4;\n    }\n\n    /**\n     * Return the cadence of notches that get labels in the secondary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n    defaultSecondaryLabelInterval(pxPerSec) {\n        if (pxPerSec >= 25) {\n            return 5;\n        } else if (pxPerSec * 5 >= 25) {\n            return 2;\n        } else if (pxPerSec * 15 >= 25) {\n            return 2;\n        }\n        return 2;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(171);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}